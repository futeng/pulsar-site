---
id: concepts-clients
title: Pulsar 客户端
sidebar_label: "客户端"
description: 全面了解 Pulsar 中 Java、C++、Go、Python、Node.js 和 C# 的客户端 API 语言绑定。
---

Pulsar 提供了支持 [Java](client-libraries-java.md)、[C++](client-libraries-cpp.md)、[Go](client-libraries-go.md)、[Python](client-libraries-python.md)、[Node.js](client-libraries-node.md) 和 [C#](client-libraries-dotnet.md) 语言绑定的客户端 API。客户端 API 优化并封装了 Pulsar 的客户端与 broker 通信协议，为应用程序提供了一个简单直观的 API。

Pulsar 客户端库支持透明的重连和/或连接故障转移到 broker，消息队列直到被 broker 确认，以及启发式机制如带退避的重连尝试。

## 客户端设置阶段

在应用程序创建生产者/消费者之前，Pulsar 客户端库需要启动一个包含两个步骤的设置阶段：

1. 客户端通过向 broker 发送 HTTP 查找请求来尝试确定主题的所有者。

    该请求可能到达一个活跃的 broker，该 broker 通过查看（缓存的）Zookeeper 元数据知道谁正在为该主题提供服务，或者在没有人提供服务的情况下，尝试将其分配给负载最低的 broker。

2. 一旦客户端库获得了 broker 地址，它会创建一个 TCP 连接（或重用池中的现有连接）并进行身份验证。

    在此连接中，客户端和 broker 交换来自自定义协议的二进制命令。此时，客户端向 broker 发送创建生产者/消费者的命令，broker 在验证授权策略后会予以响应。

每当 TCP 连接中断时，客户端会立即重新启动这个设置阶段，并以指数退避的方式不断尝试重新建立生产者或消费者，直到操作成功。

## 生产者

生产者是附加到主题并向 Pulsar [broker](concepts-architecture-overview.md#broker) 发布消息的进程。Pulsar broker 处理这些消息。

### 发送模式

发送模式是一种决定生产者是同步（sync）还是异步（async）向 broker 发送消息的机制。

| 模式         | 描述                                                                                                                                                                                                                                                                                                                                                           |
|:-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 同步发送     | 生产者在发送每条消息后等待来自 broker 的确认。如果未收到确认，生产者将发送操作视为失败。                                                                                                                                                                                                                                                                             |
| 异步发送     | 生产者将消息放入阻塞队列并立即返回。客户端库在后台将消息发送给 broker。如果队列已满（你可以[配置](reference-configuration.md#broker)最大大小），根据传递给生产者的参数，生产者在调用 API 时会被阻塞或立即失败。 |

### 访问模式

访问模式是一种决定生产者在主题上的权限的机制。

| 访问模式                 | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|:-------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Shared`                 | 多个生产者可以在一个主题上发布。<br /><br />这是**默认**设置。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `Exclusive`              | 只有一个生产者可以在一个主题上发布。<br /><br />如果已经有生产者连接，尝试在此主题上发布的其他生产者会立即收到错误。<br /><br />如果"旧"生产者与 broker 发生网络分区，"旧"生产者被驱逐，"新"生产者被选为下一个独占生产者。                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `ExclusiveWithFencing`   | 只有一个生产者可以在一个主题上发布。<br /><br />如果已经有生产者连接，它将被立即移除并失效。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `WaitForExclusive`       | 如果已经有生产者连接，生产者创建会一直挂起（而不是超时），直到生产者获得`Exclusive`访问权限。<br /><br />成功成为独占生产者的生产者被视为领导者。因此，如果要为应用程序实现领导者选举方案，可以使用这种访问模式。请注意，这里提到的领导者模式方案是指将 Pulsar 用作预写日志（WAL），这意味着领导者将其"决策"写入主题。在错误情况下，只有当领导者尝试写入消息并在适当的错误上失败时，才会被通知它不再是领导者。 |

:::note

一旦应用程序成功创建了具有`Exclusive`或`WaitForExclusive`访问模式的生产者，该应用程序实例就被保证是该主题的**唯一写入者**。任何其他尝试在此主题上生成消息的生产者要么立即得到错误，要么必须等待直到获得`Exclusive`访问权限。
更多信息，请参见 [PIP 68: Exclusive Producer](https://github.com/apache/pulsar/wiki/PIP-68:-Exclusive-Producer)。

:::

你可以通过 [Java 客户端 API](/api/client/) 设置生产者访问模式。更多信息，请参见 [ProducerBuilder.java](https://github.com/apache/pulsar/blob/fc5768ca3bbf92815d142fe30e6bfad70a1b4fc6/pulsar-client-api/src/main/java/org/apache/pulsar/client/api/ProducerBuilder.java) 文件中的`ProducerAccessMode`。


## 消费者

消费者是通过订阅附加到主题然后接收消息的进程。

![Pulsar 中消费者的消息处理工作流](/assets/consumer.svg)

消费者向 broker 发送[流许可请求](developing-binary-protocol.md#flow-control)以获取消息。消费者端有一个队列来接收从 broker 推送的消息。你可以使用[`receiverQueueSize`](pathname:///reference/#/@pulsar:version_reference@/client/client-configuration-consumer?id=receiverqueuesize)参数配置队列大小。默认大小为`1000`）。每次调用`consumer.receive()`时，会从缓冲区中取出一条消息。

### 接收模式

接收模式是一种决定是从 [broker](concepts-architecture-overview.md#brokers) 同步（sync）还是异步（async）接收消息的机制。

| 模式           | 描述                                                                                                                                                                                                             |
|:---------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 同步接收       | 同步接收会被阻塞，直到有消息可用。                                                                                                                                                                            |
| 异步接收       | 异步接收立即返回一个 future 值——例如，Java 中的[`CompletableFuture`](http://www.baeldung.com/java-completablefuture)——该值在新消息可用时完成。 |

### 监听器

客户端库为消费者提供监听器实现。例如，[Java 客户端](client-libraries-java.md)提供了[MesssageListener](/api/client/org/apache/pulsar/client/api/MessageListener)接口。在此接口中，每当接收到新消息时都会调用`received`方法。

## 读取器

在 Pulsar 中，"标准"[消费者接口](#consumer)涉及使用消费者监听[主题](concepts-messaging.md#topics)，处理传入的消息，最后在处理完这些消息时确认它们。每当创建新订阅时，它最初位于主题的末尾（默认情况下），与该订阅关联的消费者开始读取之后创建的第一条消息。每当消费者使用预先存在的订阅连接到主题时，它开始读取该订阅中最早未确认的消息。总之，使用消费者接口时，订阅游标由 Pulsar 根据响应[消息确认](concepts-messaging.md#acknowledgment)自动管理。

Pulsar 的**读取器接口**使应用程序能够手动管理游标。当你使用读取器连接到主题——而不是消费者——时，你需要指定读取器在连接到主题时从*哪个*消息开始读取。连接到主题时，读取器接口使你能够从以下位置开始：

* 主题中**最早**的可用消息。
* 主题中**最新**的可用消息。
* 最早和最新之间的其他消息。如果选择此选项，你需要显式提供消息 ID。你的应用程序将负责提前"知道"这个消息 ID，可能是从持久数据存储或缓存中获取它。

读取器接口对于诸如使用 Pulsar 为流处理系统提供有效一次处理语义等用例很有帮助。对于此用例，流处理系统必须能够将主题"倒回"到特定消息并从那里开始读取。读取器接口为 Pulsar 客户端提供了在主题内"手动定位"所需的低级抽象。

在内部，读取器接口是作为使用具有随机分配名称的独占、非持久订阅的消费者实现的。

:::tip

与订阅/消费者不同，读取器本质上是非持久的，不会阻止主题中的数据被删除，因此**强烈**建议配置[数据保留](cookbooks-retention-expiry.md)。如果没有为主题配置足够时间的数据保留，读取器尚未读取的消息可能会被删除。这导致读取器实质上跳过消息。为主题配置数据保留保证读取器有特定的时间来读取消息。

另请注意，读取器可以有"积压"，但该指标仅用于用户了解读取器的滞后程度。该指标不考虑任何积压配额计算。

:::

![Pulsar 中的消费者和读取器接口](/assets/pulsar-reader-consumer-interfaces.png)

## 表视图

表视图接口提供了一种封装的访问模式，为压缩主题数据提供持续更新的键值映射视图。没有键的消息将被忽略。

使用表视图，Pulsar 客户端可以从主题获取所有消息更新，并构建一个包含每个键最新值的映射。这些值随后可用于构建数据的本地缓存。此外，你可以通过指定监听器向表视图注册消费者，以执行映射扫描，然后在接收到新消息时接收通知。因此，可以触发事件处理来服务用例，如事件驱动应用程序和消息监控。

:::note

每个表视图每个分区使用一个读取器实例，默认从压缩视图开始读取主题。强烈建议通过为给定主题或命名空间[配置主题压缩策略](cookbooks-compaction.md#configure-compaction-to-run-automatically)来启用自动压缩。更频繁的压缩导致更短的启动时间，因为需要重放更少的数据来重建主题的表视图。从 Pulsar 2.11.0 开始，表视图还支持读取非持久主题，但不保证数据一致性。

:::

下图说明了表视图的动态构建，使用每个键的较新值更新。

![Pulsar 中表视图的动态构建](/assets/tableview.png)

## 事务

Pulsar 客户端支持事务，支持跨多个主题和分区的原子操作。事务提供恰好一次语义，并确保事务中的所有操作要么一起成功，要么一起失败。

使用事务，Pulsar 客户端可以：

* **原子消息生产**：在事务边界内原子地向多个主题生产消息。
* **原子消息确认**：在事务边界内确认消息，确保处理的消息只有在事务成功时才被提交。
* **跨主题操作**：作为单个原子事务的一部分执行跨越多个主题的操作。

### 事务工作流

1. **开始事务**：创建一个具有可配置超时的新事务。
2. **执行操作**：在事务上下文中发送消息并确认消费的消息。
3. **提交或中止**：要么提交事务（使所有操作永久化），要么中止事务（回滚所有操作）。

事务使用示例：

```java
// 创建事务
Transaction txn = client.newTransaction()
    .withTransactionTimeout(1, TimeUnit.MINUTES)
    .build().get();

try {
    // 在事务内发送消息
    producer.newMessage(txn).value("message-1").send();
    producer.newMessage(txn).value("message-2").send();

    // 在事务内确认消息
    consumer.acknowledgeAsync(messageId, txn);

    // 提交事务
    txn.commit().get();
} catch (Exception e) {
    // 出错时中止事务
    txn.abort().get();
}
```

事务对于构建恰好一次处理管道、确保多个 Pulsar 主题之间的数据一致性以及实现复杂的事件处理模式特别有用。

更多详情，请参见 [Pulsar 事务](concepts-transactions.md)。