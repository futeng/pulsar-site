---
id: txn-why
title: Why transactions?
sidebar_label: "Why transactions?"
description: Learn the use cases and limitations of transactions in Pulsar.
---

Pulsar 事务（txn）使事件流应用程序能够在一个原子操作中消费、处理和生产消息。开发此功能的原因可以总结如下。

## 流处理的需求

随着流处理的兴起，对具有更强处理保证的流处理应用程序的需求不断增长。例如，在金融行业，金融机构使用流处理引擎来处理用户的借记和贷记。这种类型的用例要求每条消息都恰好处理一次，无一例外。

换句话说，如果流处理应用程序消费消息 A 并将结果生成为消息 B（B = f(A)），那么恰好一次处理保证意味着当且仅当 B 成功生产时，A 才能被标记为已消费，反之亦然。

![Transaction in Pulsar](/assets/txn-1.png)

Pulsar 事务 API 增强了消息传递语义和流处理的处理保证。它使流处理应用程序能够在一个原子操作中消费、处理和生产消息。这意味着，事务中的一批消息可以从多个 Topic 分区接收、向多个 Topic 分区生产并由多个 Topic 分区确认。事务中涉及的所有操作都作为一个单一的单元成功或失败。

## 幂等生产者的限制

通过使用 Pulsar 幂等生产者可以避免数据丢失或重复，但它不提供跨多个分区写入的保证。

在 Pulsar 中，最高级别的消息传递保证是在单个分区上使用[幂等生产者](concepts-messaging.md#producer-idempotency)和恰好一次语义，即每条消息只持久化一次，没有数据丢失和重复。然而，这个解决方案有一些限制：

- 由于单调递增的序列 ID，此解决方案仅在单个分区和单个生产者会话中工作（即用于生产一条消息），因此向一个或多个分区生产多条消息时没有原子性。

  在这种情况下，如果在生产和接收消息的过程中出现一些故障（例如，客户端/broker/bookie 崩溃、网络故障等），消息会被重新处理和重新传递，这可能导致数据丢失或数据重复：

  - 对于生产者：如果生产者重试发送消息，一些消息会被持久化多次；如果生产者不重试发送消息，一些消息会被持久化一次，而其他消息会丢失。

  - 对于消费者：由于消费者不知道 broker 是否已收到消息，消费者可能不会重试发送确认，这导致它接收重复的消息。

- 类似地，对于 Pulsar Function，它只保证单个事件上的幂等函数的恰好一次语义，而不是处理多个事件或产生多个结果可以恰好发生。

  例如，如果一个函数接受多个事件并产生一个结果（例如，窗口函数），函数可能在生成结果和确认传入消息之间失败，甚至在确认单个事件之间失败，这导致所有（或一些）传入消息被重新传递和重新处理，并生成一个新的结果。

  然而，许多场景需要跨多个分区和会话的原子保证。

- 消费者需要依赖更多机制来一次性确认（ack）消息。

  例如，消费者需要存储 MessageID 及其确认状态。Topic 卸载后，当 Topic 再次加载时，订阅可以在内存中恢复此 MessageID 的确认状态。