---
author: Matteo Merli, Sijie Guo
title: "Apache Pulsar 2.8.0"
---

# 2.8.0 版本概览

我们很高兴地看到 Apache Pulsar 社区成功发布了 2.8.0 版本，其中包括许多激动人心的升级和增强功能。这篇博客深入探讨了 2.8.0 版本的更新，以及详细介绍了帮助 Pulsar 演变为今天统一消息和流处理平台的主要 Pulsar 发展。

<!--truncate-->

注意：Pulsar 社区通常每 3 个月发布一个主要版本，但自 2.7.0 发布以来已经过去了 6 个月。我们在 2.8.0 上花费了更多时间，以使事务 API 对 Pulsar 社区普遍可用。

# 2.8 版本概览

此版本中的关键功能和更新是：
- 独占生产者
- 包管理 API
- 简化的客户端内存限制设置
- Broker 条目元数据
- 新的 Protobuf 代码生成器
- 事务

## 独占生产者

默认情况下，Pulsar 生产者 API 提供"多写入者"语义，用于向主题追加消息。但是，有几个用例需要单个写入者的独占访问，如确保消息的线性非交错历史或提供领导者选举机制。

这个新功能允许应用程序要求独占生产者访问以实现"单写入者"情况。它保证在任何错误组合中都应该只有 1 个单写入者。如果生产者失去其独占访问，它的更多消息就不能再发布到主题上。

此功能的一个用例是 Pulsar Functions 中的元数据控制器。为了写入所有函数元数据更新的单一线性历史，元数据控制器需要选举一个领导者，并且该领导者做出的所有"决策"都被写入元数据主题。通过利用独占生产者功能，Pulsar 保证元数据主题包含不同的更新段，每个连续领导者一个，并且跨不同领导者没有交错。有关更多详细信息，请参见"[PIP-68: 独占生产者](https://github.com/apache/pulsar/wiki/PIP-68%3A-Exclusive-Producer)"。

## 包管理 API

自 2.0 版本引入以来，Functions API 在 Pulsar 用户中变得非常流行。虽然它提供了许多好处，但有许多方法可以改善用户体验。例如，今天，如果一个函数被多次部署，函数包最终会被多次上传。此外，Pulsar 中没有对 Functions 和 IO 连接器的版本管理。新引入的包管理 API 提供了一种更简单的方法来管理 Functions 和 IO 连接器的包，并显著简化了升级和回滚过程。阅读"[包管理 API](http://pulsar.apache.org/docs/en/admin-api-packages/)"了解更多详细信息。

## 简化的客户端内存限制设置

在 2.8 之前，生产者和消费者中有多个设置允许控制内部消息队列的大小。这些设置最终控制 Pulsar 客户端使用的内存量。但是，这种方法存在一些问题，使得选择控制内存总使用量的整体配置变得复杂。

例如，设置基于"消息数量"，因此必须为每个生产者或消费者调整预期消息大小。如果应用程序有大量（或未知数量）的生产者或消费者，很难为队列大小选择适当的值。对于具有许多分区的主题也是如此。

在 2.8 中，我们引入了一个新的 API 来设置内存限制。这个单一的 `memoryLimit` 设置指定给定 Pulsar 客户端上的最大内存量。生产者和消费者竞争分配的内存。它确保 Pulsar 客户端使用的内存不会超过设定的限制。阅读"[PIP-74: Pulsar 客户端内存限制](https://github.com/apache/pulsar/wiki/PIP-74%3A-Pulsar-client-memory-limits)"了解更多详细信息。

## Broker 条目元数据

Pulsar 消息定义了一组非常全面的元数据属性。但是，要添加新属性，Pulsar 协议中的 `MessageMetadata` 定义必须更改，以通知 broker 和客户端新引入的属性。

但在某些情况下，此元数据属性可能需要从 broker 端添加，或者需要 broker 以非常低的成本检索。为了防止从消息元数据反序列化这些属性，我们在 2.8.0 中引入了"Broker 条目元数据"，以提供一种轻量级方法来添加额外的元数据属性，而无需序列化和反序列化 protobuf 编码的 `MessageMetadata`。

此功能为 Pulsar 解锁了一组新的能力。例如，我们可以利用 broker 条目元数据为追加到 Pulsar 主题的消息生成 broker 发布时间。另一个例子是为生成到 Pulsar 主题的消息生成单调递增的序列 ID。我们在 Kafka-on-Pulsar 中使用此功能来实现 Kafka 偏移量。

## 新的 Protobuf 代码生成器

Pulsar 使用 Google Protobuf 来对客户端和 broker 之间交换的命令执行序列化和反序列化。由于常规 Protobuf 实现的开销，我们一直使用修改版的 Protobuf 2.4.1。这些修改是为了确保更高效的序列化代码，该代码对过程中使用的对象使用线程本地缓存。

这种方法引入了一些问题。例如，Protobuf 代码生成器的补丁仅基于 Protobuf 版本 2.4.1，无法升级到更新的 Protobuf 版本。在 2.8 中，我们将修补的 Protobuf 2.4.1 切换到 Splunk LightProto 作为代码生成器。新的代码生成器为 Protobuf SerDe 生成最快的 Java 代码，与 proto2 定义和线协议 100% 兼容，并使用 Netty ByteBuf 提供零拷贝反序列化。

## 事务

在 Pulsar 2.8 之前，Pulsar 仅通过幂等生产者支持单主题上的精确一次语义。虽然功能强大，但幂等生产者只解决了精确一次语义的狭小范围挑战。例如，当生产者尝试向多个主题生成消息时没有"原子性"。当为其中一个主题服务的 broker 崩溃时，可能发生发布错误。如果生产者不重试再次发布消息，会导致一些消息被持久化一次而其他消息丢失。如果生产者重试，会导致一些消息被多次持久化。

为了解决上述剩余的挑战，我们通过引入 Pulsar 事务 API 来支持跨多个主题的原子写入和确认，从而加强了 Pulsar 的传递语义。事务 API 添加到 Apache Pulsar 完成了我们使 Pulsar 成为完整统一消息和流处理平台的愿景。

Pulsar PMC 成员 Penghui Li 在他最近的博客中详细介绍了此功能，Pulsar 中使用事务的精确一次语义。您可以阅读它以了解更多关于[Pulsar 中的精确一次语义支持](https://streamnative.io/en/blog/release/2021-06-14-exactly-once-semantics-with-transactions-in-pulsar)。

# 使用 Apache Pulsar 构建统一消息和流处理平台

## Apache Pulsar 的演进

Apache Pulsar 被全球数百家公司广泛采用，包括 Splunk、腾讯、Verizon 和 Yahoo! JAPAN 等。作为云原生分布式消息系统诞生的 Apache Pulsar 已经演变为完整的消息和流处理平台，用于大规模实时地发布、订阅、存储和处理数据流。

早在 2012 年，雅虎团队正在寻找一个能够管理所有雅虎消息数据的全球、异地复制基础设施。在审查了消息和流处理领域后，很明显现有技术无法满足事件驱动组织的需求。因此，雅虎团队开始构建自己的系统。

当时，通常有两种类型的系统来处理动态数据：实时处理关键业务事件的消息队列，以及大规模处理可扩展数据管道的流处理系统。公司不得不将其能力限制在其中一个，或者他们必须采用多种不同的技术。如果他们选择多种技术，他们最终会得到一个复杂的基础设施，通常导致数据隔离和数据孤岛，一个孤岛用于构建应用程序服务的消息队列，另一个孤岛用于构建数据服务的流处理系统。下图说明了这可能的样子。

![](/img/280-1.png)

然而，随着公司需要处理的数据多样性超越了运营数据（如日志数据、点击事件等），加上需要访问合并业务数据和运营数据的下游系统数量的增加，系统需要支持消息队列和流处理。

除此之外，公司需要一个基础设施平台，允许他们在其上构建所有应用程序，然后这些应用程序默认处理动态数据（消息和流数据）。这样实时数据基础设施可以显著简化，如下图所示。

![](/img/280-2.png)

有了这个愿景，雅虎团队开始构建用于动态数据的统一消息和流处理平台。以下是 Pulsar 从创立到今天的关键里程碑概览。

## 第 1 步：为数据流提供可扩展的存储

Pulsar 的旅程始于 Apache BookKeeper。Apache BookKeeper 为连续流实现了类似日志的抽象，并提供了以互联网规模运行它的能力，具有简单的写入-读取日志 API。日志为构建分布式系统（如分布式数据库和发布-订阅消息）提供了很好的抽象。写入 API 以追加到日志的形式。读取 API 以从读取器定义的起始偏移量连续读取的形式。BookKeeper 的实现创建了基础 - 可扩展的日志支持的消息和流处理系统。

## 第 2 步：将计算与存储分离的多层架构

在可扩展的日志存储之上，引入了无状态服务层，它运行无状态 brokers 用于发布和消费消息。这种多层架构将服务/计算与存储分离，允许 Pulsar 在单独的层中管理服务和存储。

这种架构还确保了即时可扩展性和更高可用性。这两个因素都非常重要，使 Pulsar 非常适合构建关键任务服务，如金融用例的计费平台、电子商务和零售商的事务处理系统，以及金融机构的实时风险控制系统。

## 第 3 步：统一消息模型和 API

在现代数据架构中，实时用例通常可以分为两类：队列和流处理。队列通常用于构建核心业务应用程序服务，而流处理通常用于构建实时数据服务，如数据管道。

为了提供一个能够为应用程序服务和数据服务服务的平台，需要一个统一的消息模型，集成队列和流处理语义。Pulsar 主题成为消费的事实来源。消息只能在主题上存储一次，但可以通过不同的订阅以不同方式消费。这种统一显著降低了管理和开发消息和流处理应用程序的复杂性。

## 第 4 步：Schema API

接下来，添加了新的 Pulsar schema 注册中心和新的类型安全生产者和消费者 API。内置的 schema 注册中心使 Pulsar 主题上的消息生产者和消费者能够通过 Pulsar broker 本身协调主题数据的结构，而无需外部协调机制。使用数据模式，通过 Pulsar 传输的每一数据都是完全可发现的，使您能够构建可以轻松适应数据变化的系统。

此外，schema 注册中心跟踪模式版本之间的数据兼容性。当上传新模式时，注册中心确保新模式版本能够被旧消费者读取。这确保生产者不会破坏消费者。

## 第 5 步：Functions 和 IO API

下一步是构建 API，使数据进出 Pulsar 并处理它变得容易。目标是使用 Apache Pulsar 轻松构建事件驱动应用程序和实时数据管道，因此无论事件源自何处，您都可以在事件到达时处理它们。

Pulsar IO API 允许您通过插入各种源连接器将数据从外部系统获取到 Pulsar，以及使用接收连接器将数据从 Pulsar 获取到外部系统来构建实时流数据管道。今天，Pulsar 提供了几个您可以使用的内置连接器。

此外，StreamNative Hub（Pulsar 连接器注册中心）提供了与流行数据系统集成的数十个连接器。如果 IO API 用于构建流数据管道，Functions API 用于构建事件驱动应用程序和实时流处理器。

无服务器函数概念被采用到流处理中，然后构建了 Functions API 作为轻量级无服务器库，您可以使用任何您喜欢的语言编写任何事件处理逻辑。潜在的动机是使您的工程团队能够编写流处理逻辑，而没有运行和维护另一个集群的操作复杂性。

## 第 6 步：通过分层存储为 Pulsar 提供无限存储

随着 Apache Pulsar 的采用持续增加，存储在 Pulsar 中的数据量增加，用户最终遇到了"保留悬崖"，此时在 Apache BookKeeper 中存储、管理和检索数据的成本显著增加。为了解决这个问题，运营商和应用程序开发人员通常使用外部存储如 AWS S3 作为长期存储的接收器。这意味着您失去了 Pulsar 不可变流和排序语义的大部分好处，而最终必须管理具有不同访问模式的两个不同系统。

分层存储的引入允许 Pulsar 将大部分数据卸载到远程云原生存储。这种更便宜的存储形式可以随着数据量轻松扩展。更重要的是，随着分层存储的添加，Pulsar 提供了与统一批处理和流处理器（如 Flink）集成时支持批处理所需的批存储能力。与 Pulsar 集成的统一批处理和流处理能力使公司能够快速轻松地查询具有历史上下文的实时流，解锁独特的竞争优势。

## 第 7 步：协议处理器

在引入分层存储后，Pulsar 从发布/订阅消息系统演变为可摄取、存储和处理数据流的可扩展流数据系统。但是，使用其他消息协议（如 Kafka、AMQP、MQTT 等）编写的现有应用程序必须重写以采用 Pulsar 的消息协议。

协议处理器 API 进一步降低了采用 Pulsar 构建消息和流处理应用程序的开销，并允许开发人员通过利用 Pulsar 架构提供的所有好处将 Pulsar 能力扩展到其他消息域。这导致了 Pulsar 与其他行业领导者之间的主要合作，以开发流行的协议处理器，包括：
- [Kafka-on-Pulsar (KoP)](https://hub.streamnative.io/protocol-handlers/kop/0.2.0)，由 OVHCloud 和 StreamNative 于[2020 年 3 月推出](https://streamnative.io/en/blog/tech/2020-03-24-bring-native-kafka-protocol-support-to-apache-pulsar)。
- [AMQP-on-Pulsar (AoP)](https://hub.streamnative.io/protocol-handlers/aop/0.1.0)，由中国移动和 StreamNative 于[2020 年 6 月宣布](https://streamnative.io/en/blog/tech/2020-06-15-announcing-aop-on-pulsar)。
- [MQTT-on-Pulsar (MoP)](https://hub.streamnative.io/protocol-handlers/mop/0.2.0)，由 StreamNative 于[2020 年 8 月宣布](https://streamnative.io/en/blog/tech/2020-09-28-announcing-mqtt-on-pulsar)。
- [RocketMQ-on-Pulsar (RoP)](https://github.com/streamnative/rop)，由腾讯云和 StreamNative 于 2021 年 5 月推出。

## 第 8 步：用于精确一次流处理的事务 API

最近，向 Apache Pulsar 添加了事务，以实现流处理的精确一次语义。这是一个基本功能，为流数据转换提供了强大的保证，使构建可扩展、容错、有状态的消息和流处理应用程序来处理数据流变得容易。

此外，事务 API 能力不限于给定的语言客户端。Pulsar 对事务消息和流处理的支持主要是一种协议级别的能力，可以在任何语言中呈现。这种协议级别的能力可以在各种应用程序中利用。

# 为统一消息和流处理构建生态系统

除了为 Pulsar 技术做出贡献外，社区还在努力构建一个强大的生态系统来支持它。Pulsar 支持丰富的发布-订阅库、连接器、函数、协议处理器以及与流行查询引擎集成的生态系统，将使 Pulsar 采用者能够简化工作流程并实现新的用例。

# 下一步是什么？

如果您有兴趣了解更多关于 Pulsar 2.8.0 的信息，您可以[下载 2.8.0](https://pulsar.apache.org/en/versions/) 并立即试用！

如果您想了解更多关于公司如何采用 Pulsar 的信息，您可以[注册](https://hopin.com/events/pulsar-summit-north-america-2021)参加 Pulsar Summit NA 2021！

有关 Apache Pulsar 项目和进展的更多信息，请访问官方网站 https://pulsar.apache.org 并在 Twitter [@apache_pulsar](https://twitter.com/apache_pulsar) 上关注项目。