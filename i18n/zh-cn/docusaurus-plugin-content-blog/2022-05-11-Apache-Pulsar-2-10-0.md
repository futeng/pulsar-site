---
title: "Apache Pulsar 2.10 的新功能"
date: 2022-05-11
author: "Penghui Li, Dave Duggins"
---

Apache Pulsar 社区发布了 2.10 版本。99 位贡献者提供了改进和错误修复，共计超过 800 个提交。

<!--truncate-->

# 本版本亮点：

- Pulsar 提供主备集群之间的自动故障恢复。#13316
  - 原始 PIP [#13315](https://www.google.com/url?q=https://github.com/apache/pulsar/issues/13315&sa=D&source=docs&ust=1646058957138073&usg=AOvVaw3mGki2sHW2QpIsoYf5pt3w)
- 通过向 `PartitionedProducer` 添加懒加载功能，需要更少的生产者并更有效地使用 broker 内存。#10279
- 通过新的 `TableView` 类型添加主题映射支持，使用接收消息中的键值对。

本博客记录了此版本中最值得注意的更改。有关包含所有功能、增强和错误修复的完整列表，请查看 [Pulsar 2.10.1 发布说明](https://pulsar.apache.org/release-notes/#placeholder)。

# 值得注意的错误修复和增强
***
#### 集群
***

##### 客户端 Pulsar 集群级自动故障切换 #13316

**问题：** Pulsar 管理员必须手动进行集群故障切换。

**解决方案：** 添加了 Pulsar 集群级自动故障切换功能，当检测到故障切换事件时，自动无缝地从主集群切换到一个或多个辅助集群。当主集群恢复时，客户端自动切换回去。

##### 多集群主题策略 #12517

**问题：** 地理复制集群的某些主题策略影响整个地理复制集群，而某些只影响本地集群。

**解决方案：** 主题策略现在支持跨集群复制。
- 对于本地主题策略，设置消息的 `replicateTo` 属性以避免被复制到远程。
- 保留支持设置全局参数。
- 为 `SystemTopicBasedTopicPoliciesService` 添加了全局主题策略。

***
#### 生产者
***

##### 向 PartitionedProducer 添加懒加载功能 #10279

**问题：** 根据最高速率生产者设置分区数量时，最低速率生产者并不总是需要连接到每个分区，因此额外的生产者会占用 broker 内存。

**解决方案：** 通过为分区生产者引入懒加载来减少生产者数量以更有效地使用 broker 内存；还添加了轮循路由模式类来限制分区数量。

##### [客户端] 引入分块消息 ID #12403

**问题：** 发送分块消息时，生产者返回最后一个分块的消息 ID，导致某些进程中出现不正确的行为。

**解决方案：** 引入了新的 `ChunkMessage-ID` 类型。分块消息 ID 继承自 `MessageIdImpl` 并添加了两个新方法：`getFirstChunkMessageId` 和 `getLastChunkMessageID`。对于其他方法实现，直接调用 `lastChunkMessageID`，这与现有的许多业务逻辑兼容。

***
#### Broker
***

##### Broker 扩展允许企业级集群操作员更好地控制和灵活性 #12536

**问题：** 企业 Pulsar 集群操作员需要更大的灵活性和控制来拦截 broker 事件（包括账本写入/读取）以进行模板验证、可观察性和访问控制。

**解决方案：**
- 增强了 org.apache.pulsar.broker.intercept.BrokerInterceptor 接口，包含用于跟踪的额外事件
- 创建了新接口 org.apache.pulsar.common.intercept.MessagePayloadProcessor 以允许拦截账本写入/读取操作
- 增强了 PulsarAdmin，为操作员提供管理超级用户的控制

***
#### 消费者
***

##### 重新传递命令添加 epoch #10478

**问题：** 拉取和重新传递操作是异步的，因此客户端消费者可能会接收到新消息，基于新的 messageID 执行累积确认，并无法消费旧消息。

**解决方案：** Pulsar 客户端使用为服务器和客户端消费者递增的 epoch 来同步重新传递和拉取消息操作。

##### 支持在 Dispatcher 中插入可插拔的条目过滤器 #12269

**问题：** 不原生支持消息标记。

**解决方案：** 在 broker 级别实现了条目过滤器框架。正在努力在即将发布的版本中支持命名空间和主题级别。

##### 在发送消息到 DLQ 之前创建初始订阅 #13355

**问题：** 未处理消息中的 DLQ 数据会自动被删除，没有为命名空间或 DLQ 设置数据保留策略。

**解决方案：** 现在在发送消息到 DLQ 之前创建初始订阅。
当 `deadLetterProducer` 被初始化时，消费者根据 `DeadLetterPolicy` 设置初始订阅。

##### 对确认超时应用重新传递退避策略 #13707

**问题：** PIP 106 中最近引入的重新传递退避策略仅适用于否定确认 API。如果使用确认超时来触发消息重新传递而不是否定确认 API，则退避策略被绕过。

**解决方案：**
- 对确认超时应用消息重新传递策略。
- 将 `NegativeAckBackoff` 接口重命名为 `RedeliveryBackoff`。
- 在 `ConsumerBuilder` 中暴露 `AckTimeoutRedeliveryBackoff`。
- 添加了单元测试用例。

目前只有 Java 客户端被修改。

##### 解决设置主题级 maxMessageSize 时产生分块消息失败的问题 #13599

**问题：** 当前，如果主题级 maxMessageSize 设置为 [1]，则分块消息产生失败。

**解决方案：** 在 `PublishContext` 中添加了 `isChunked`。如果是分块消息，则跳过 `maxMessageSize` 检查。

***
#### Function
***

##### Pulsar Functions：预加载和释放外部资源 #13205

**问题：** 外部资源初始化和释放要么手动完成，要么通过使用复杂的初始化逻辑来完成。

**解决方案：** 引入了 `RichFunction` 接口，通过提供 setup 和 tearDown API 来扩展 `Function`。

***
##### 更新认证接口以包含异步认证方法 #12104

**问题：** Pulsar 当前的 `AuthenticationProvider` 接口只暴露用于认证连接的同步方法。到目前为止，这已经足够了，因为我们没有任何依赖网络调用的提供者。然而，在查看 OAuth2.0 规范时，有些情况下需要网络调用来验证令牌。

**解决方案：**
###### AuthenticationProvider
- 添加了 `AuthenticationProvider#authenticateAsync`。包含了调用 authenticate 方法的默认实现。
- 弃用了 `AuthenticationProvider#authenticate`。
- 添加了 `AuthenticationProvider#authenticateHttpRequestAsync`。
- 弃用了 `AuthenticationProvider#authenticateHttpRequest`。
##### AuthenticationState
- 添加了 `AuthenticationState#authenticateAsync`。
- 弃用了 `AuthenticationState#authenticate`。首选方法是 `AuthenticationState#authenticateAsync`。
- 弃用了 `AuthenticationState#isComplete`。可以通过从 `AuthenticationState#authenticateAsync` 的结果推断认证完成性来避免此方法。
##### AuthenticationDataSource
- 弃用了 `AuthenticationDataSource#authenticate`。不需要此方法的异步版本。

***
##### TableView 的初始提交 #12838

**问题：** 在许多用例中，应用程序使用 Pulsar 消费者或读取器来获取主题的所有更新，并为接收消息的每个键的最新值构建映射。这在构建数据的本地缓存时很常见。我们在 Pulsar 客户端 API 中不包含对此访问模式的支持。

**解决方案：** 添加了新的 `TableView` 类型并更新了 PulsarClient。

***
#### 主题
***

##### 支持主题元数据 - PART-1 创建带有属性的主题 #12818

**问题：** 无法存储主题元数据。

**解决方案：**
- 在 topics.java 中添加了新的存储方法。
- 为 REST API 添加了两个新路径以减少兼容性问题。

***
#### 元数据存储
***

##### 添加 Etcd MetadataStore 实现 #13225

**问题：** 我们正在努力添加支持非 Zookeeper 实现的元数据后端。

**解决方案：** 为以下内容添加了 Etcd 支持：
- 读/写请求批处理
- 会话监视器
- 租约管理器